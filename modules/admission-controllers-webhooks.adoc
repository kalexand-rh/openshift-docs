// Module included in the following assemblies:
//
// * architecture/admission-controllers.adoc

[id='admission-controllers-webhooks-{context}']
= Webhooks

[IMPORTANT]
====
*Admission webhooks* is a Technology Preview feature only.
ifdef::openshift-enterprise[]
Technology Preview features are not supported with Red Hat production service
level agreements (SLAs), might not be functionally complete, and Red Hat does
not recommend to use them for production. These features provide early access to
upcoming product features, enabling customers to test functionality and provide
feedback during the development process.

For more information on Red Hat Technology Preview features support scope, see
https://access.redhat.com/support/offerings/techpreview/.
endif::[]
====

In addition to the default admission controllers,
you can use _admission webhooks_ as part of the admission chain.

Admission webhooks call webhook servers to either mutate pods upon creation,
such as to inject labels,
or to validate specific aspects of the pod configuration during the admission process.

Admission webhooks intercept requests to the master API prior to the persistence
of a resource, but after the request is authenticated and authorized.

There are two types of admission webhook objects you can configure:

* Mutating admission webhooks allow for the use of mutating webhooks to modify
resource content before it is persisted. They are invoked during the mutation
phase of the admission process, which allows modification of the resource content
before it is persisted.
One example of a mutating admission webhook is the Pod Node Selector feature,
which uses an annotation on a namespace to find a label selector and add it to the pod specification.

* Validating admission webhooks allow for the use of validating webhooks to
enforce custom admission policies. They are invoked during the validation phase
of the admission process. This phase allows the enforcement of invariants on
particular API resources to ensure that the resource does not change again. The
Pod Node Selector is also an example of a validation admission, by ensuring that
all `nodeSelector` fields are constrained by the node selector restrictions on
the project.

Webhooks must adhere to an
https://github.com/kubernetes/kubernetes/blob/v1.10.0-beta.1/staging/src/k8s.io/api/admission/v1beta1/types.go#L28[interface]
in order to work properly with {product-title}.

When an object is instantiated, {product-title} makes an API call to admit the
object. During the admission process, a _mutating admission controller_
can invoke webhooks to perform tasks, such as injecting affinity labels. At
the end of the admissions process,
a _validating admission controller_ can invoke webhooks to make sure the object
is configured properly, such as verifying affinity labels.
If the validation passes, {product-title} schedules the object as configured.

When the API request comes in, the mutating or validating admission controller
uses the list of external webhooks in the configuration and calls them in parallel:

* If *all* of the webhooks approve the request, the admission chain continues.

* If *any* of the webhooks deny the request, the admission request is denied, and
the reason for doing so is based on the _first_ webhook denial reason.
+
If more than one webhook denies the admission request,
only the first will be returned to the user.

* If there is an error encountered when calling a
webhook, that request is ignored and is be used to approve/deny the
admission request.

The following diagram illustrates this process with two admission webhooks that call multiple webhooks.

image::api-server-pipeline.png["API admission stage", align="center"]

A simple example use case for admission webhooks is syntactical validation
of resources. For example, you have an infrastructure that requires all pods to
have a common set of labels, and you do not want any pod to be
persisted if the pod does not have those labels. You could write a webhook to inject these labels
and another webhook to verify that the labels are present.
The {product-title} will then schedule pod that have the labels and pass validation
and reject pods that do not pass due to missing labels.

Some common use-cases include:

* Mutating resources to inject side-car containers into pods.
* Restricting projects to block some resources from a project.
* Custom resource validation to perform complex validation on dependent fields.