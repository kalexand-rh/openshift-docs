// Module included in the following assemblies:
//
// * architecture/architecture.adoc

[id='architecture-overview-{context}']
= Architecture overview

Like {product-title} v3, {product-title} v4 is a layered system designed to
expose underlying container images and Kubernetes concepts as accurately as
possible, with a focus on easy composition of applications by a developer.
For example, after your cluster is running, install Ruby, push code, and add
MySQL to the app.

A major difference between {product-title} v3 and v4 is that v4 uses Operators
as both the fundamental unit of the product and an option for easily deploying
and managing utilities that your apps use.

{product-title} has an Operator-based architecture of smaller, decoupled units
that work together. It runs on top of a Kubernetes cluster, with data about the
objects stored in etcd, a reliable clustered key-value store. Those services are
broken down by function:

* Operators, which run the core {product-title} services.
* REST APIs, which expose each of the core objects:
** Containers and images, which are the building blocks for deploying your
applications.
** Pods and services, which containers use to communicate with each other and
proxy connections.
** Projects and users, which provide the space and means for communities to
organize and manage their content together.
** Builds and image streams] allow you to
build working images and react to new images.
** Deployments, which expand support for the software development and deployment
lifecycle.
** Routes, which announce your service to the world.
** Templates, which allow you to simultaneously create many objects that are
based on customized parameters.
* Controllers, which read those REST APIs, apply changes to other objects, and
report status or write back to the object.

Users make calls to the REST API to change the state of the system. Controllers
use the REST API to read the user's desired state and then try to bring the
other parts of the system into sync. For example, when you request a build, the
REST APIs create a `build` object. The build controller sees that a new build has been created, and
runs a process on the cluster to perform that build. When the build completes,
the controller updates the build object via the REST API and the user sees that
their build is complete.

The controller pattern means that much of the functionality in {product-title}
is extensible. The way that builds are run and launched can be customized
independently of how images are managed, or how deployments happen. The controllers
perform the "business logic" of the system, taking user actions and
transforming them into reality. By customizing those controllers or replacing
them with your own logic, you can implement different behaviors. From a system
administration perspective, this also means that you can use the API to script common
administrative actions on a repeating schedule. Those scripts are also
controllers that watch for changes and take action. {product-title} makes the
ability to customize the cluster in this way a first-class behavior.

To make this possible, controllers use a reliable stream of changes to the
system to sync their view of the system with what users are doing. This event
stream pushes changes from etcd to the REST API and then to the controllers as
soon as changes occur so changes can efficiently ripple through the system.
However, because failures can occur at any time, the controllers
must also be able to get the latest state of the system at start up and confirm
that everything is in the right state. This resynchronization is important
because it means that even if something goes wrong, you can
restart the affected components, and the system confirms its status before it
continues. Because the controllers can always bring the system into sync, the
system eventually converges to your intent.
