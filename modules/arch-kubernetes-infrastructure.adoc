// Module included in the following assemblies:
//
// * architecture/kubernetes.adoc

[id='kubernetes-infrastructure-{context}']
= Kubernetes infrastructure

Within {product-title}, Kubernetes manages containerized applications across a
set of containers or hosts and provides mechanisms for deployment, maintenance,
and application-scaling. The container runtime packages, instantiates, and runs
containerized applications. A Kubernetes cluster consists of one or more masters
and a set of nodes.

[NOTE]
====
{product-title}
ifdef::openshift-enterprise,openshift-dedicated[]
{product-version}
endif::[]
uses Kubernetes 1.10 and Docker 1.13.
====

[id='master-{context}']
== Masters

The master is the host or hosts that contain the control plane components,
including the API server, controller manager server, and etcd. The master
manages nodes in its Kubernetes cluster and schedules
pods to run on those nodes.

[id='master-components-{context}']
[cols="1,4"]
.Master components
|===
|Component |Description

|API Server
|The Kubernetes API server validates and configures the data for pods, services,
and replication controllers. It also assigns pods to nodes and synchronizes pod
information with service configuration.

|etcd
|etcd stores the persistent master state while other components watch etcd
for changes to bring themselves into the desired state. etcd can be optionally
configured for high availability, typically deployed with 2n+1 peer services.

|Controller Manager Server
|The controller manager server watches etcd for changes to replication
controller objects and then uses the API to enforce the desired state.
Several such processes create a cluster with
one active leader at a time.

|HAProxy
a|Optional, used when configuring
highly-available masters with the `native`
method to balance load between API master endpoints.

ifdef::openshift-enterprise,openshift-origin[]
The cluster installation process
can configure HAProxy for you with the `native` method. Alternatively, you can
use the `native` method but pre-configure your own load balancer of choice.
endif::[]
|===

[id='control-plane-static-pods-{context}']
=== Control plane static pods

The core control plane components, the API
server and the controller manager components, run as
link:https://kubernetes.io/docs/tasks/administer-cluster/static-pod/[_static pods_]
operated by the kubelet.

For masters that have etcd co-located on the same host, etcd is also moved to
static pods. RPM-based etcd is still supported on etcd hosts that are not also
masters.

In addition, the node components `openshift-sdn` and
`openvswitch` are now run using a DaemonSet instead of a `systemd` service.

.Control plane host architecture changes
image::ocp310-archupgrade.png["Control plane host architecture changes"]

ifdef::openshift-enterprise,openshift-origin[]
[discrete]
[id='control-plane-static-pods-mirror-pods-{context}']
==== Mirror Pods

The kubelet on master nodes automatically creates _mirror pods_ on the API
server for each of the control plane static pods so that they are visible in the
cluster in the `kube-system` project. Manifests for these static pods are
installed by default by the `openshift-ansible` installer, located in the
`/etc/origin/node/pods` directory on the master host.

These pods have the following `hostPath` volumes defined:

[horizontal]
`/etc/origin/master`:: Contains all certificates, configuration files, and the `admin.kubeconfig` file.
`/var/lib/origin`:: Contains volumes and potential core dumps of the binary.
`/etc/origin/cloudprovider`:: Contains cloud provider specific configuration (AWS, Azure, etc.).
`/usr/libexec/kubernetes/kubelet-plugins`:: Contains additional third party volume plug-ins.
`/etc/origin/kubelet-plugins`:: Contains additional third party volume plug-ins for system containers.

The set of operations you can do on the static pods is limited.
endif::[]

ifdef::openshift-origin,openshift-enterprise,openshift-dedicated[]
[id='high-availability-masters-{context}']

=== High Availability Masters

The availability of running applications remains if the master or any of its services fail.
However, failure of master services reduces the ability of the system to respond to
application failures or creation of new applications.
endif::[]
ifdef::openshift-origin,openshift-enterprise[]
You can optionally configure your masters for high
availability (HA) to ensure that the cluster has no single point of failure.

To mitigate concerns about availability of the master, two activities are
recommended:

1. A https://en.wikipedia.org/wiki/Runbook[runbook] entry should be created for
reconstructing the master. A runbook entry is a necessary backstop for any
highly-available service. Additional solutions merely control the frequency
that the runbook must be consulted. For example, a cold standby of the master
host can adequately fulfill SLAs that require no more than minutes of downtime
for creation of new applications or recovery of failed application components.

2. Use a high availability solution to configure your masters and ensure that the
cluster has no single point of failure. The cluster
installation documentation provides specific examples using the `native` HA method and
configuring HAProxy. You can also take the concepts and apply them towards your
existing HA solutions using the `native` method instead of HAProxy.

[NOTE]
====
In production {product-title} clusters, you must maintain high availability
of the API Server load balancer. If the API Server load balancer is not
available, nodes cannot report their status, all their pods are marked dead,
and the pods' endpoints are removed from the service.
In addition to configuring HA for {product-title}, you must separately configure
HA for the API Server load balancer. To configure HA, it is much preferred to
integrate an enterprise load balancer (LB) such as an F5 Big-IP™ or a Citrix
Netscaler™ appliance. If such solutions are not available, it is possible to
run multiple HAProxy load balancers and use Keepalived to provide a floating
virtual IP address for HA. However, this solution is not recommended for
production instances.
====

endif::[]

ifdef::openshift-origin,openshift-enterprise,openshift-dedicated[]
When using the `native` HA method with HAProxy, master components have the
following availability:

[cols="1,1,3"]
.Availability Matrix with HAProxy
|===
|Role |Style |Notes

|etcd
|Active-active
|Fully redundant deployment with load balancing.
ifdef::openshift-origin,openshift-enterprise[]
Can be installed on separate hosts or collocated on master hosts.
endif::[]

|API Server
|Active-active
|Managed by HAProxy.

|Controller Manager Server
|Active-passive
|One instance is elected as a cluster leader at a time.

|HAProxy
|Active-passive
|Balances load between API master endpoints.
|===
endif::[]

ifdef::openshift-origin,openshift-enterprise[]
While clustered etcd requires an odd number of hosts for quorum, the master
services have no quorum or requirement that they have an odd number of hosts.
However, since you need at least two master services for HA, it is common to
maintain a uniform odd number of hosts when collocating master services and
etcd.
endif::[]

[id='node-{context}']
== Nodes

A node provides the runtime environments for containers. Each node in a
Kubernetes cluster has the required services to be managed by the master. Nodes
also have the required services to run pods, including the container runtime, a
kubelet, and a service proxy.

{product-title} creates nodes from a cloud provider, physical systems, or virtual
systems. Kubernetes interacts with node objects
that are a representation of those nodes. The master uses the information from
node objects to validate nodes with health checks. A node is ignored until it
passes the health checks, and the master continues checking nodes until they are
valid. The link:https://kubernetes.io/docs/concepts/architecture/nodes/#management[Kubernetes documentation]
has more information on node statuses and management.

ifdef::openshift-enterprise,openshift-origin[]
Administrators can manage nodes in an
{product-title} instance using the CLI. To define full configuration and security
options when launching node servers, use
dedicated node configuration files.

[IMPORTANT]
====
See the cluster
limits section for the recommended maximum number of nodes.
====
endif::[]

[id='kubelet-{context}']
=== Kubelet

Each node has a kubelet that updates the node as specified by a container
manifest, which is a YAML file that describes a pod. The kubelet uses a set of
manifests to ensure that its containers are started and that they continue to
run.

A container manifest can be provided to a kubelet by:

- A file path on the command line that is checked every 20 seconds.
- An HTTP endpoint passed on the command line that is checked every 20 seconds.
- The kubelet watching an etcd server, such as `/registry/hosts/$(hostname -f)`, and acting on any changes.
- The kubelet listening for HTTP and responding to a simple API to submit a new
 manifest.

[id='service-proxy-{context}']
=== Service Proxy

Each node also runs a simple network proxy that reflects the services defined in
the API on that node. This allows the node to do simple TCP and UDP stream
forwarding across a set of back ends.

[id='node-object-definition-{context}']
=== Node Object Definition

The following is an example node object definition in Kubernetes:

[source,yaml]
----
apiVersion: v1 <1>
kind: Node <2>
metadata:
  creationTimestamp: null
  labels: <3>
    kubernetes.io/hostname: node1.example.com
  name: node1.example.com <4>
spec:
  externalID: node1.example.com <5>
status:
  nodeInfo:
    bootID: ""
    containerRuntimeVersion: ""
    kernelVersion: ""
    kubeProxyVersion: ""
    kubeletVersion: ""
    machineID: ""
    osImage: ""
    systemUUID: ""
----
<1> `apiVersion` defines the API version to use.
<2> `kind` set to `Node` identifies this as a definition for a node
object.
<3> `metadata.labels` lists any labels that have been added to the node.
<4> `metadata.name` is a required value that defines the name of the node
object. This value is shown in the `NAME` column when running the `oc get nodes`
command.
<5> `spec.externalID` defines the fully-qualified domain name where the node
can be reached. Defaults to the `metadata.name` value when empty.

[id='node-bootstrapping-{context}']
=== Node Bootstrapping

A node's configuration is bootstrapped from
the master, which means nodes pull their pre-defined configuration and client
and server certificates from the master. This allows faster node start-up by
reducing the differences between nodes, as well as centralizing more
configuration and letting the cluster converge on the desired state. Certificate
rotation and centralized certificate management are enabled by default.

.Node bootstrapping workflow overview
image::node_bootstrapping.png["Node bootstrapping workflow overview"]

When node services are started, the node checks if the
`/etc/origin/node/node.kubeconfig` file and other node configuration files
exist before joining the cluster. If they do not, the node pulls the
configuration from the master, then joins the cluster.

ConfigMaps are used
to store the node configuration in the cluster, which populates the
configuration file on the node host at `/etc/origin/node/node-config.yaml`.
ifdef::openshift-enterprise,openshift-origin[]
For definitions of the set of default node groups and their ConfigMaps, see
Defining Node Groups and Host Mappings
in Installing Clusters.
endif::[]

