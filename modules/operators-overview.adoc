// Module included in the following assemblies:
//
// * architecture/architecture.adoc

[id='operators-overview-{context}']
= Operators in {product-title}

In {product-title} version 4.0, all cluster functions are divided into a series
of component Operators.

Operators can manage other Operators within their component. This lends to a
transparent model: a single Operator usually manages a single binary file.
Operators also offer a more granual configuration experience. You configure each component by
modifying its Operator instead of modifying a global configuration file.

In version 4.0, separate processes and images and pods run to drive the kubernetes
API and pod managers. The control plane services run as static pods so they can
manage normal workloads or processes the same way that they manage disaster
recovery. Aside from the core control plane components, other services run as 
normal pods on the cluster, managed by regular Kubernetes constructs. Unlike in the past
where the `kubelet` could be running as containerized or non-containerized, the `kubelet`
always runs as a `systemd` process.


[id='cluster-version-operator-{context}']
== The cluster version Operator

The cluster version Operator orchestrates all things.

{product-title} 4.0 introduces several new components that support the cluster
version Operator, including Cincinnati and Telemetry.

Cincinnati is the hosted service that provides over the air updates to both 
{product-title} and RHCOS. It provides a graph, or diagram that contain
_vertices_ and the _edges_ that connect them, of component Operators. The edges
in the graph show which versions you can safely upgrade to. The cluster version
Operator checks with Cincinnati and determines valid upgrades and upgrade paths
based on current component versions and information in the graph. If you
configure it to do so, Cincinnati sends the release artifacts that it needs to
perform the upgrade to your image registry, and the cluster version Operator
upgrades your cluster. By accepting automatic updates, you can automatically
keep your cluster up to date with the most recent compatible components.

To allow Cincinnati to provide only compatible updates, a release verification
pipeline exists to drive automation. Each release artifact is verified for
compatibility with supported cloud platforms and system architectures as well
as other component packages. After the pipeline confirms the suitability of a 
release, Cincinnati can apply the update to your cluster or notify you that it
is available.

The interaction between the registry and the Cincinnati service is different during
bootstrap and continuous update modes. When you bootstrap the initial
infrastructure, the cluster version Operator finds 
the fully qualified image name for the shortname of the images that it needs to 
apply to the server during installation. It looks at the image stream that it needs
to apply and renders it to disk. It calls bootkube and waits for a temporary minimal control
plane to come up and load the cluster version Operator.

During continuous update mode, two controllers run. One continuously updates
the payload manifests, applies them to the cluster, and outputs the status of
the controlled rollout of the Operators, whether they are available, upgrading,
or failed. The second controller constantly checks with to Cincinnati to
determine if updates are available.

In a managed Red Hat environment, Telemetry is the component that provides
metrics about cluster health and the success of updates.

[id='second-level-operators-{context}']
== Second-level Operators in {product-title}

The cluster version Operator, when we talk about payload manifests, is a
second-level Operator, the Operators that actually manage {product-title} as if
it were a native Kubernetes application. Second-level Operators are not a
codified concept, but thenamespace where your code exists, the service accounts
or roles the second-level Operator runs as, the CRD and pull secret that drives
the operation of the Operator, and the Operator deployment.

Second-level Operators write out to a CRD resource called the cluster Operator
that allows the cluster version Operator to understand the progress of the
managed component's deployment

[id='OLM-operators-{context}']
== Operators managed by OLM

In addition to the Operators that comprise {product-title}, the Cluster
Operator Lifecycle Management (OLM) component manages more Operators.
OLM is a framework that manages Kubernetes-native applications as Operators.
Instead of managing Kubernetes manifests, it manages Kubernetes Operators.
OLM manages two classes of Operators, Red Hat Operators and certified Operators.

Some Red Hat Operators drive the cluster functions, like the scheduler and
problem detectors. Others are provider for you to manage yourself and use in
your applications, like etcd. {product-title} also offers certified Operators,
which the community built around the OLM and maintains. These certified Operators
are traditional applications that are Kubernetes-aware because they are wrapped
in an Operator.
